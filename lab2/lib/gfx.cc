#include "lib/gfx.h"
#include "lib/math.h"

namespace
{

    // generate a circular shape spanning from `left` to `right` with `center` as its center
    // Note: this is used for adding smooth endpoints of lines
    std::vector<sf::Vector2f> generate_cap(sf::Vector2f left, sf::Vector2f center,
                                           sf::Vector2f right)
    {
        std::vector<sf::Vector2f> result { };
    
        // The caps are generated by extrapolating two radii, center->left and
        // center->right and then generating a circular shape where we slowly
        // interpolate between the two radii.
        //
        // The circular shape is calculated by linearly interpolating between
        // left and center+normal for 0 <= t <= 0.5 and center+normal + right
        // for 0.5 < t <= 1, where the resulting vector is normalized
        // (i.e. turned into a unit vector) and then multiplied by the
        // interpolated radius. Note that `normal` is the normal vector of
        // left->right.
        //
        // Note that the order of `left` and `right` matter for what part of
        // circle will be drawn. The circle will be drawn starting from `left`
        // and the turn clockwise until it hits `right`.

        float const r1 { length(center - left) };
        float const r2 { length(center - right) };

        // the number of triangles is dependent on the size, this way we have nice
        // scaling for all sizes. The formula below was determined experimentally.
        std::size_t const triangle_count(std::ceil(std::max( (r1 + r2) / 3.0f, 2.0f )));
        
        sf::Vector2f const u1 { (left  - center) / r1 };
        sf::Vector2f const u2 { (right - center) / r1 };
        
        sf::Vector2f const n { normal(right - left) };
    
        std::vector<sf::Vector2f> points { };

        // calculate all the points along the cap
        float const scale { static_cast<float>(triangle_count) };
        for (std::size_t i { 0 }; i < triangle_count + 1; ++i)
        {
            float const t { static_cast<float>(i) / scale };
            
            float const l { (1.0f - t) * r1 + t * r2 };
        
            if (t <= 0.5f)
            {
                float const s { 2.0f * t };
                sf::Vector2f const d { normalize( (1.0f - s) * u1 + s * n ) };
                points.push_back(center + l * d);
            }
            else
            {
                float const s { 2.0f * (t - 0.5f) };
                sf::Vector2f const d { normalize( (1.0f - s) * n + s * u2 ) };
                points.push_back(center + l * d);
            }
        }

        // generate each triangle in the shape
        for (std::size_t i { 1 }; i < points.size(); ++i)
        {
            result.push_back(points[i - 1]);
            result.push_back(points[i]);
            result.push_back(center);
        }

        return result;
    }

}

void draw_line(sf::RenderTarget& target, sf::Vector2f from, sf::Vector2f to,
               sf::Color color, float thickness)
{
    if (length_squared(from - to) < 1e-6)
        return;

    // we create a shape of triangles for the line: basically a large rectangle
    // with circular caps at the endpoints of the line. The diameter of the
    // circular shapes are `thickness`.

    sf::VertexArray vertices { sf::Triangles };

    sf::Vector2f const n { (0.5f*thickness) * normal(to - from) };

    // calculate each corner of the rectangle
    sf::Vector2f const p0 { from - n };
    sf::Vector2f const p1 { from + n };
    sf::Vector2f const p2 { to   + n };
    sf::Vector2f const p3 { to   - n };
        
    // generate and construct cap for the endpoint at `from`
    for (sf::Vector2f p : generate_cap(p0, from, p1))
        vertices.append({ p, color });

    // construct the rectangle
    vertices.append({ p0, color });
    vertices.append({ p1, color });
    vertices.append({ p2, color });

    vertices.append({ p0, color });
    vertices.append({ p2, color });
    vertices.append({ p3, color });

    // generate and construct cap for the endpoint at `to`
    for (sf::Vector2f p : generate_cap(p2, to, p3))
        vertices.append({ p, color });

    target.draw(vertices);
}

void draw_path(sf::RenderTarget& target, std::vector<sf::Vector2f> const& path,
               sf::Color color, float thickness)
{
    // For now we do the na√Øve implementation where we just draw a line between
    // each consecutive pair of points.
    for (std::size_t i { 1 }; i < path.size(); ++i)
        draw_line(target, path[i - 1], path[i], color, thickness);
}

void draw_arrow_tip(sf::RenderTarget& target, sf::Vector2f base, sf::Vector2f tip,
                    sf::Color color, float thickness)
{
    float const size { length(tip - base) };
    sf::Vector2f const d { normalize(tip - base) };
    sf::Vector2f const n { normal   (tip - base) };

    sf::Vector2f lwing { base + 0.75f*size*normalize(n - d) };
    sf::Vector2f rwing { base - 0.75f*size*normalize(n + d) };

    sf::VertexArray caps { sf::Triangles };
    sf::VertexArray vertices { sf::TriangleFan };
    if (std::abs(thickness) >= 1.0f)
    {
        sf::Vector2f const louter {  thickness*normal(tip - lwing) };
        sf::Vector2f const router { -thickness*normal(tip - rwing) };

        sf::Vector2f const linner {  thickness*normal(lwing - base) };
        sf::Vector2f const rinner { -thickness*normal(rwing - base) };

        base = intersection(lwing + linner, base + linner,
                            rwing + rinner, base + rinner);

        vertices.append({ base          , color });
        vertices.append({ lwing + linner, color });
        vertices.append({ lwing + louter, color });
        vertices.append({ tip   + louter, color });
        vertices.append({ tip   + router, color });
        vertices.append({ rwing + router, color });
        vertices.append({ rwing + rinner, color });

        // cap for arrow tip
        for (sf::Vector2f p : generate_cap(tip + louter, tip, tip + router))
            caps.append({ p, color });

        // cap for left wing
        for (sf::Vector2f p : generate_cap(lwing + linner, lwing, lwing + louter))
            caps.append({ p, color });

        // cap for right wing
        for (sf::Vector2f p : generate_cap(rwing + router, rwing, rwing + rinner))
            caps.append({ p, color });
    }
    else
    {
        vertices.append({ base , color });
        vertices.append({ lwing, color });
        vertices.append({ tip  , color });
        vertices.append({ rwing, color });
    }

    target.draw(caps);
    target.draw(vertices);
}

void draw_path_single_arrow(sf::RenderTarget& target, std::vector<sf::Vector2f> const& path,
                            sf::Vector2f tip,
                            float line_thickness, sf::Color color, float thickness)
{
    draw_path(target, path, color, line_thickness + 2.0f*thickness);
    draw_arrow_tip(target, path.back(), tip, color, thickness);
}

void draw_path_double_arrow(sf::RenderTarget& target, std::vector<sf::Vector2f> const& path,
                            sf::Vector2f begin_tip, sf::Vector2f end_tip,
                            float line_thickness, sf::Color color, float thickness)
{
    draw_path_single_arrow(target, path, end_tip, line_thickness, color, thickness);
    draw_arrow_tip(target, path.front(), begin_tip, color, thickness);
}
